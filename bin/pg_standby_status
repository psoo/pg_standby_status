#!/usr/bin/perl

=head1 NAME

pg_standby_status - Status Monitor for PostgreSQL Hot Standby Servers

=head1 SYNOPSIS

pg_standby_status --primary=MASTER_DSN [ --slave=STANDBY_DSN1, ... ]

=head1 OPTIONS

=over

=item B<--report=lag-received>

Report the lag for received transaction logs (Streaming Replication only) in
megabytes. This option supports non-interactive mode only and pg_standby_mode
will exit immediately after printing the results.

=item B<--report=lag-replayed>

Report the lag for replayed transaction logs (Streaming Replication only) in
megabytes. This option supports non-interactive mode only and pg_standby_mode
will exit immediately after printing the results.

=item B<--refresh=secs>

Refresh the interactive status monitor after this time.

=back

=head1 DESCRIPTION

pg_standby_status is a status monitor which is able to display the lag of
transaction logs and offsets of PostgreSQL standby servers, which are running with
hot_standby = on. Thus this program requires at least PostgreSQL 9.0. It doesn't matter
wether you are running a streaming replication setup or a WAL-shipping solution,
though.

=head1 DISCUSSION

pg_standby_status currently supports an interactive mode and a single, non-interactive
action via the command line option B<-report>. When using the command line option
B<--report>, you are required to specify a reporting action. The currently supported reporting
actions are:

lag-received
lag-replayed

In interactive mode, pg_standby_status currently prints the status of the primary
node on the first line of the status monitor output:

    M= 192.168.1.6:5445 3E/5B05DE30 keep 64

The M= indicates the position of the primary node, followed by its IP and port
number. The XX/XXXXXXXX formatted string displays the current segment id and
offset in the transaction log. The "keep" keyword tells how many wal_keep_segments
are currently configured on the primary node. Next to the primary node status line, each
standby is printed per line, introduced by the S= flag. Until the XX/XXXXXXXX string,
the status line matches the one for the primary node. After this, the replay keyword
dispays the distance of the WAL segment id from the standby to the primary node (segid)
and its number of WAL segments it is behind (count) replaying. The WAL records actually
received from the master during streaming replication are displayed by the recv() values.

Next to each S= line there is a  summary line, indicated by a '>>' string. It displays
the absolute position of the transaction log (XX/XX) on the master and the standby so
it can be compared manually. The first value is the WAL segment id, the second the
WAL segment number of the current WAL segment id. Additionally, the replication lag
for replayed transactions are displayed, in MByte, telling how behind of WAL volume
the standby is, and a time value, telling how far behind in time the last replayed
WAL record is.

    S=    192.168.1.6:5446 3E/5B05DE30 replay(segid=0/count=0) recv(segid=0/count=0)
       STREAMING possible
       -M>>S=(3E/91 3E/91) 0 MB, time 00:00:01.087401

The status monitor displays a status string next to each S= line, telling the
user wether it is possible for the standby server to stream from the primary's
transaction log ("STREAMING possible"). When the transaction lag counter exceeds the
wal_keep_segments of the primary node, the status monitor will change to the string
"RECOVER FROM ARCHIVE required". When the standby catches up and falls below the
threshold of wal_keep_segments of the primary,
it will change back to "STREAMING possible". However, this doesn't indicate that
the specific standby will return to streaming mode immediately. It just means that
the PostgreSQL server likely will switch back to streaming mode soon, once it has
absorbed all required WAL segments from the archive.

=head1 RETURN CODES

Since pg_standby_status currently dies on database errors, there might be some
confusion about specific error codes  and which one belongs to which error
condition. This might be subject to change in the future, when pg_standby_status
gets a more sane error handling once.

=cut

use strict;
use DBI;
use Curses;
use Getopt::Long;
use Pod::Usage;
use version; our $VERSION = q(0.4);

my $bTerm = 0;

##
## Handle exit
##
sub exit_sig() {
    $bTerm = 1;
}

##
## Retrieve the current WAL position on the primary. Returns
## a hash reference with all informations
##
sub WALLocationPrimary(%) {
    my %args = @_;

    my $db = $args{DBH};

    ## It is sufficient to obtain the major version number of
    ## the connected database server from the primary only. We are
    ## required to run the streaming standby with the same major
    ## number, so no need to do it in WALLocationStandby() again.
    my $sth = $db->prepare(qq/SELECT pg_current_wal_lsn() AS location,
                                     (SELECT a.setting::int4 * b.setting::int4
                                      FROM pg_settings a, pg_settings b
                                      WHERE a.name = 'wal_segment_size'
                                            AND b.name = 'wal_block_size') AS walsegsize,
                              current_setting('block_size') AS walblocksize,
                              current_setting('wal_keep_segments') AS wal_keep_segments,
                              current_setting('server_version_num') AS pg_version_primary;/)
        || die "error executing pg_current_wal_lsn on master\n";
    my %location = {};
    $sth->execute();

    ## host and port info
    $location{PGHOST} = $db->{pg_host};
    $location{PGPORT} = $db->{pg_port};

    ## We catch some more informations on the primary, since we
    ## need some of the compile time settings to calculate the WAL offsets.
    ## Note that we easily can rely on those settings on the standby, too,
    ## since we must be binary compatible there.

    if (my $hashref = $sth->fetchrow_hashref()) {
        $location{WALLOCATION} = $hashref->{location};
        $location{WALSEGSIZE}  = $hashref->{walsegsize};
        $location{WALBLKSIZE}  = $hashref->{walblocksize};
        $location{WAL_KEEP_SEGMENTS} = $hashref->{wal_keep_segments};
	$location{PG_VERSION_PRIMARY} = $hashref->{pg_version_primary};
    }

    $sth->finish();
    return %location;
}

## Calculates the distance between two WAL locations
##
## This does the guts of this holy tool. We get the
## current WALSEGID/WALOFFSET via WALLocationPrimary() and
## WALLocationStandby() and calculate the following values,
## returned by a hash reference (and its equally named key):
##
## WALSEGID = Distance between the SEGID from standby to primary
## WALCOUNT = Distance between current WAL segment on primary
##            and standby
## MASTER_WALSEGID = current WALSEGID on the primary
## SLAVE_WALSEGID  = current WALSEGID on the standby
## MASTER_WALCOUNT = current WAL segment on the primary
## SLAVE_WALCOUNT  = current WAL segment on the standby
##
## The time we calculate the values might be outdated: the standby and the
## primary might already advanced their WAL offsets, so the value
## will likely appear a little "off".
##
sub WALDistance($$) {

    ## NOTE: master_location is passed as a hash reference
    my ($master_location, $standby_location) = @_;
    my ($master_walid, $master_waloffset) = split '/', $master_location->{WALLOCATION};
    my ($standby_walid, $standby_waloffset) = split '/', $standby_location;

    ## convert hex values of walsegid
    $master_walid = hex("$master_walid");
    $standby_walid = hex("$standby_walid");

    ## calculate the number of the current segment of the current WALSEGID. This is relativ to
    ## the starting segment of the current WALSEGID.

    my $master_log = 1 + hex("FF") - ((hex("FF000000")
                                       - (hex($master_waloffset))) / $master_location->{WALSEGSIZE});
    my $standby_log = 1 + hex("FF") - ((hex("FF000000")
                                        - (hex($standby_waloffset))) / $master_location->{WALSEGSIZE});
    my %distance = {};
    $distance{WALSEGID} = hex("$master_walid") - hex("$standby_walid");

    ## Calculate the current distance of number of WAL segments between
    ## the primary and the standby.

    $distance{WALCOUNT} = ($master_walid * hex("FF") + $master_log)
        - ($standby_walid * hex("FF") + $standby_log);

    ## record remaining values

    $distance{MASTER_WALSEGID} = $master_walid;
    $distance{SLAVE_WALSEGID}  = $standby_walid;
    $distance{MASTER_WALCOUNT} = $master_log;
    $distance{SLAVE_WALCOUNT}  = $standby_log;
    $distance{SLAVE_WAL_BACKLOG_SZ} = $distance{WALCOUNT} * $master_location->{WALSEGSIZE};

    return %distance;
}

##
## Retrieve the last replayed WAL location from the primary
##
## Returns a hash with the following keys/values:
## WALLOCATION    :  Last location replayed by the standby
## WALRECVLOCATION:  Last location received by streaming
## WALTIMELAG     :  The time lag of replayed transactions records
##                   Calculates the distance between the last replayed
##                   WAL timestamp and current.
## STANDBYENABLED  : The standby is in recovery mode (true)
##                   or was normally started (false).
##                   If the latter is the case, this standby is not
##                   really replicating.
## PGHOST: hostname of the standby (eases tracking from which
##         standby this information comes)
## PGPORT: port of the standby
##
## WALRECVLOCATION might not yet be initialized when streaming
## wasn't enabled or wasn't started yet on the specified standby.
##
sub WALLocationStandby(%) {
    my %args  = @_;
    my $db    = $args{DBH};
    my $pgver = $args{PG_VERSION_PRIMARY};
    my $sth;

    if ($pgver >= 90100) {
	$sth = $db->prepare(qq/SELECT pg_is_in_recovery() AS standby_enabled,
                                      pg_last_wal_receive_lsn() AS receive,
                                      pg_last_wal_replay_lsn() AS location,
                                      localtimestamp - pg_last_xact_replay_timestamp()::timestamp without time zone AS time;/)
        || die "error executing pg_last_wal_replay_lsn on standby\n";
    }
    else {
	$sth = $db->prepare(qq/SELECT pg_is_in_recovery() AS standby_enabled,
                                      pg_last_wal_receive_lsn() AS receive,
                                      pg_last_wal_replay_lsn() AS location,
                                      NULL::timestamp without time zone AS time;/)
        || die "error retrieving WAL receive/replay location on standby\n";
    }
    my %standby_info = {};
    $sth->execute();

    if (my $hashref = $sth->fetchrow_hashref()) {
        $standby_info{STANDBYENABLED}   = $hashref->{standby_enabled};
        $standby_info{WALLOCATION}     = $hashref->{location};
        $standby_info{WALRECVLOCATION} = $hashref->{receive};
	$standby_info{WALTIMELAG}      = $hashref->{time} || "not available";
    }

    $standby_info{PGHOST} = $db->{pg_host};
    $standby_info{PGPORT} = $db->{pg_port};

    $sth->finish();
    return \%standby_info;
}

##
## Aggregates all standby WALLocationStandby() hash references
## from all standby nodes.
##
sub WALStandbyLocations(%) {
    my %args = @_;
    my @standby = @{$args{DBHS}};
    my $pgversion = $args{PG_VERSION_PRIMARY};
    my @locations;

    for (my $i = 0; $i <= $#standby; $i++) {
        $locations[$i] = WALLocationStandby(DBH => $standby[$i],
                                            PG_VERSION_PRIMARY => $pgversion);
    }

    return @locations;
}

##
## Handle program exit. Terminate all database connections.
##
sub pss_exit(%) {
    my %args = @_;
    my $dbh = $args{DBH};

    if ($dbh) {
	$dbh->disconnect();
    }

    foreach my $slave (@{$args{DBHS}}) {
	$slave->disconnect();
    }
}

my $dsn_master = undef;
my $dbh_master = undef;

my @dsn_slaves    = ();
my @dbh_slaves    = ();
my $report_action = undef;
my $refresh       = 5; ## refresh every 5 secs

$SIG{TERM} = \&exit_sig;
$SIG{INT}  = \&exit_sig;

GetOptions(
    "report=s" => \$report_action,
    "primary=s" => \$dsn_master,
    "slave=s"   => \@dsn_slaves,
    "refresh=i" => \$refresh,
    "help"     => sub { pod2usage(-exit => 0, -verbose => 99, -sections => 'NAME|SYNOPSIS|OPTIONS'); }
    );

## connect to primary
$dbh_master = DBI->connect("dbi:Pg:".$dsn_master,
                              "",
                              "",
                              { RaiseError => 1, AutoCommit => 1})
    || die DBI::errstr;

## connect to all given standby nodes
for(my $i = 0; $i <= $#dsn_slaves; $i++) {
    $dbh_slaves[$i] = DBI->connect("dbi:Pg:".$dsn_slaves[$i],
				   "",
				   "",
				   { RaiseError => 1, AutoCommit => 1 })
        || die DBI::errstr;
}

################################################################################
## Handle command line options first, _before_ entering interactive mode
################################################################################

if ($report_action) {

    my %master_location = WALLocationPrimary(DBH => $dbh_master);
    my @standby_locations = WALStandbyLocations(DBHS => \@dbh_slaves,
                                                PG_VERSION_PRIMARY => $master_location{PG_VERSION_PRIMARY});

    foreach my $location (@standby_locations) {

	my %distance_replay;
	my %distance_recv;

	## calculate distance from primary for each standby
	%distance_replay = WALDistance(\%master_location, $location->{WALLOCATION});
	%distance_recv   = WALDistance(\%master_location, $location->{WALRECVLOCATION});


	if ($report_action eq "lag-replayed") {

	    printf "%s:%s %s:%s %u\n", $master_location{PGHOST}, $master_location{PGPORT},
	    $location->{PGHOST}, $location->{PGPORT},
	    $distance_replay{SLAVE_WAL_BACKLOG_SZ} / 1024 / 1024;

	} elsif ($report_action eq "lag-received") {

	    printf "%s:%s %s:%s %u\n", $master_location{PGHOST}, $master_location{PGPORT},
	    $location->{PGHOST}, $location->{PGPORT},
	    $distance_recv{SLAVE_WAL_BACKLOG_SZ} / 1024 / 1024;

	} elsif ($report_action eq "lag-replayed-time") {

	    printf "%s:%s %s:%s %s\n", $master_location{PGHOST}, $master_location{PGPORT},
	    $location->{PGHOST}, $location->{PGPORT},
	    $location->{WALTIMELAG};

	} else {

	    print STDERR "unsupported action for --report: \"$report_action\"";
	    exit(1);

	}

    }

    ## leave non-interactive mode immediately after processing --report...
    pss_exit(DBH => $dbh_master, DBHS => \@dbh_slaves);
    exit(0);

}

################################################################################
## Curses initialization, interactive mode...
################################################################################

initscr;
start_color;
init_pair(1, COLOR_CYAN, COLOR_BLACK);
init_pair(2, COLOR_RED, COLOR_BLACK);

while(1) {

    my %master_location = WALLocationPrimary(DBH => $dbh_master);
    my @standby_locations = WALStandbyLocations(DBHS => \@dbh_slaves,
                                                PG_VERSION_PRIMARY => $master_location{PG_VERSION_PRIMARY});

    my $standby_locstr;
    my $extra_locstr;

    erase();
    attron(A_BOLD);
    printw(sprintf "M= %s:%s %8s keep %d\n", $master_location{PGHOST}, $master_location{PGPORT},
           $master_location{WALLOCATION}, $master_location{WAL_KEEP_SEGMENTS});
    attroff(A_BOLD);
    addstr("");

    foreach my $location (@standby_locations) {
        my %distance; ## distance xlog's replayed
        my %distance_recv;  ## distance xlog's received by streaming

        ## is this standby in recovery mode ??
        if (!$location->{STANDBYENABLED}) {
            ## oops, seems this is not a standby server,
            ## mark it accordingly and step forward to the next
            ## standby, if any

            $standby_locstr = sprintf "   %s:%s is not in recovery mode\n",
                              $location->{PGHOST}, $location->{PGPORT};
            printw("S= ");
            attron(COLOR_PAIR(2));
            printw($standby_locstr);
            attroff(COLOR_PAIR(2));
            next;
        }

        ## Calculate the distance of WALs replayed between master and standby
        %distance = WALDistance(\%master_location, $location->{WALLOCATION});

        ## Calculate the distance of WALs received from master
        %distance_recv = WALDistance(\%master_location, $location->{WALRECVLOCATION});

        ## Materialize output
        $standby_locstr = sprintf "   %s:%s %s replay(segid=%d/count=%d) recv(segid=%d/count=%d)\n",
                                  $location->{PGHOST}, $location->{PGPORT},
                                  $location->{WALLOCATION}, $distance{WALSEGID},
                                  $distance{WALCOUNT}, $distance_recv{WALSEGID},
                                  $distance_recv{WALCOUNT};
        $extra_locstr = sprintf "   -M>>S=(%X/%d %X/%d) lag %u MB, time %s\n", $distance{MASTER_WALSEGID},
                                $distance{MASTER_WALCOUNT}, $distance{SLAVE_WALSEGID},
                                $distance{SLAVE_WALCOUNT},
                                $distance{SLAVE_WAL_BACKLOG_SZ} / 1024 / 1024,
                                $location->{WALTIMELAG};

        ## check wether the current receive lag will likely exceed the available
        ## WAL segments located on the primary. Give a warning when
        ## we exceed wal_keep_segments. If wal_keep_segments isn't used
        ## (set to 0), then there isn't much sense in this check, so go
        ## just forward in this case.
        ##
        ## NOTE: this will return to 'STREAMING possible' as soon as the standby
        ## doesn't lag more than WALCOUNT > WAL_KEEP_SEGMENTS.
        ## However, this doesn't mean that the standby *will* immediately return
        ## into WAL streaming. The PostgreSQL startup process will seek the WAL
        ## segments from archive until it has absorbed all available segments and can
        ## safely return to streaming mode.

        if ($master_location{WAL_KEEP_SEGMENTS} == 0) {
            printw(sprintf "S= %s ", $standby_locstr);
            attron(COLOR_PAIR(1));
            printw("  STREAMING\n");
            attroff(COLOR_PAIR(1));
            next;
        } elsif ($master_location{WAL_KEEP_SEGMENTS} > $distance_recv{WALCOUNT}) {
            printw(sprintf "S= %s ", $standby_locstr);
            attron(COLOR_PAIR(1));
            printw("  STREAMING possible\n");
            attroff(COLOR_PAIR(1));
        } else {
            printw(sprintf "S= %s ", $standby_locstr);
            attron(COLOR_PAIR(2));
            printw("  RECOVER FROM ARCHIVE required\n");
            attroff(COLOR_PAIR(2));
        }

        printw($extra_locstr);
        addstr("");
    }

    refresh();

    ## check for exit signal
    last if ($bTerm);

    sleep $refresh;
}

endwin;

pss_exit(DBH => $dbh_master, DBHS => \@dbh_slaves);
exit(0);
